Process:
1. Start in main
2. Main uses arguments from the user in order to begin process
3. Arguments are parsed into an abstract (changeable) structure
4. Main instantiates the project by hooking the appropriate command executors into each step of the process. This can use a singleton in order to retrieve the default executors used; main may chose whether or not to use these executors
5. Main instructs the process to begin using a single method in some abstract class (template pattern!)

Implementation details:
6. Using the abstracted arguments, begin the process of deciding which steps need to be run
	- This can be done by passing the abstracted arguments into a dedicated method of each hook, asking if it needs to run
7. Start with the transformation from the asm into an abstracted tree structure - call this a graph?
	- This will not be exposed through the API since this step is not expected to change
	- The tree structure should have NO information regarding UML, style information, etc. It should only expose the necessary information about nodes in a nice way. Consider using the adapter pattern
	- Allow the execution of arbitrary requests on the asm node objects using some sort of command pattern. Perhaps the command can be passed in the asm node object.
8. Next, use the graph in order to begin building the dot file. This should come in two stages:
	a. Add custom information to the graph (i.e. x node needs to be red because it violates some principle). Use composition of graph, not add directly to it.
	b. Use custom information in order to render the graph into dot
9. Pass the created dot graph into a 'lastpass' stage, where an executor is free to do what it wishes with the dot graph.